<?php

/**
 * @file
 * Defines a reference field widget that allows for inline entity
 * creation, updating, and deletion on another entity's add / edit form.
 */


/**
 * Implements hook_theme().
 */
function commerce_ipf_theme() {
  return array(
    'commerce_ipf_entity_table' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_field_widget_info().
 */
function commerce_ipf_field_widget_info() {
  $widgets = array();

  // Define the inline product form widget for the product reference field.
  $widgets['commerce_inline_product_form'] = array(
    'label' => t('Inline product form'),
    'description' => t('Display a product add / edit form that can reference existing products or create new products on the fly.'),
    'field types' => array('commerce_product_reference'),
    'settings' => array(),
    'behaviors' => array(
      'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      'default value' => FIELD_BEHAVIOR_NONE,
    ),
  );

  return $widgets;
}

/**
 * Introspects field and instance settings, and determines the correct settings
 * for the functioning of the widget.
 *
 * Settings:
 *   - entity_type - The entity_type being managed.
 *   - bundles - Bundles of entities that the user is allowed to create.
 *   - column - The name of the ref. field column that stores the entity id.
 */
function commerce_ipf_settings($field, $instance) {
  $settings = array(
    'entity_type' => NULL,
    'bundles' => array(),
    'column' => NULL,
  );

  if ($field['type'] == 'commerce_product_reference') {
    $settings['entity_type'] = 'commerce_product';
    $settings['column'] = 'product_id';

    // The product reference field has its bundle setting, use it.
    $types = array_filter($instance['settings']['referenceable_types']);
    if (!empty($types)) {
      $settings['bundles'] = array_values($types);
    }
  }

  // By default, allow entities of all bundles to be created.
  if (empty($settings['bundles'])) {
    $info = entity_get_info($settings['entity_type']);
    foreach ($info['bundles'] as $bundle_name => $bundle_info) {
      $settings['bundles'][] = $bundle_name;
    }
  }

  return $settings;
}

/**
 * Implements hook_field_widget_form().
 */
function commerce_ipf_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  static $parents_delta = array();

  $widget = $instance['widget'];
  $settings = commerce_ipf_settings($field, $instance);

  if ($widget['type'] == 'commerce_inline_product_form') {
    // Build a parents array for this element's values in the form.
    $parents = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language']));
    $parents_key = strtr(implode('-', $parents), '_', '-');

    if (!isset($parents_delta[$parents_key])) {
      $parents_delta[$parents_key] = count($parents_delta);
    }

    // Determine the wrapper ID for the entire element.
    $wrapper = 'commerce-ipf-' . $parents_key;
    $element['#prefix'] = '<div id="' . $wrapper . '">';
    $element['#suffix'] = '</div>';
    $element['#attached']['css'][] = drupal_get_path('module', 'commerce_ipf') . '/theme/commerce_ipf.css';

    // Load the entities from the $items array and store them in the form state
    // for further manipulation if this is the first time the widget form is
    // being built.
    if (empty($form_state['commerce_ipf'][$parents_key])) {
      // Initialize the last action to NULL.
      $form_state['commerce_ipf'][$parents_key]['action'] = NULL;

      // Add the element's settings to the array.
      $form_state['commerce_ipf'][$parents_key]['settings'] = $settings;

      // Extract the entity IDs from the items array and load the entities.
      $form_state['commerce_ipf'][$parents_key]['entities'] = array();
      $entity_ids = array();
      foreach ($items as $item) {
        $entity_ids[] = $item[$settings['column']];
      }

      $delta = 0;
      foreach (entity_load($settings['entity_type'], $entity_ids) as $entity) {
        $form_state['commerce_ipf'][$parents_key]['entities'][$delta] = array(
          'data' => $entity,
          'weight' => $delta,
          'form' => NULL,
          'needs_save' => FALSE,
        );

        $delta++;
      }

      // If no entities were found, include a new one on an add form.
      if (empty($form_state['commerce_ipf'][$parents_key]['entities']) && count($settings['bundles']) == 1) {
        $info = entity_get_info($settings['entity_type']);
        $bundle_key = $info['entity keys']['bundle'];
        $default_values = array();
        // If the bundle key exists, it must always be set on an entity.
        if (!empty($bundle_key)) {
          $default_values[$bundle_key] = reset($settings['bundles']);
        }
        $form_state['commerce_ipf'][$parents_key]['entities'][$delta] = array(
          'data' => entity_create($settings['entity_type'], $default_values),
          'weight' => 0,
          'form' => 'add',
          'needs_save' => FALSE,
        );
      }
    }

    // Include the IPF callbacks.
    module_load_include('inc', 'commerce_ipf', 'includes/commerce_product.forms');

    $element['entities'] = array('#tree' => TRUE, '#theme' => 'commerce_ipf_entity_table');
    // Get all entities from form_state (some of which might not yet exist in
    // the database), and pass them to the table building callback.
    $entities = array();
    foreach ($form_state['commerce_ipf'][$parents_key]['entities'] as $key => $value) {
      $entities[] = $value['data'];
    }
    $entity_table = commerce_ipf_commerce_product_build_table($entities);
    $element['entities']['#table_header'] = $entity_table['#header'];

    foreach ($form_state['commerce_ipf'][$parents_key]['entities'] as $key => $value) {
      $entity = $value['data'];

      // Handle row weights.
      $element['entities'][$key]['#weight'] = $value['weight'];
      $element['entities'][$key]['delta'] = array(
        '#type' => 'weight',
        '#delta' => 50,
        '#default_value' => $value['weight'],
        '#attributes' => array('class' => array('commerce-ipf-entity-delta')),
      );

      // First check to see if this entity should be displayed as a form.
      if (!empty($value['form'])) {
        $element['entities'][$key]['form'] = array(
          '#type' => 'container',
          '#attributes' => array('class' => array('commerce-ipf-product-title')),
        );
        $element['entities'][$key]['form']['actions'] = array(
          '#type' => 'container',
          '#weight' => 100,
        );
        // Prepare data for the form callbacks.
        $form = &$element['entities'][$key]['form'];
        $form_parents = array_merge($parents, array('entities', $key, 'form'));
        module_load_include('inc', 'commerce_ipf', 'includes/commerce_product.forms');

        // Add the entity add / edit form.
        if ($value['form'] == 'add' || $value['form'] == 'edit') {
          $form += commerce_ipf_commerce_product_form($form, $form_state, $form_parents, $entity);

          $form['actions']['ipf_' . $value['form'] . '_save'] = array(
            '#type' => 'submit',
            '#value' => t('Save product'),
            '#name' => 'ipf-' . $parents_delta[$parents_key] . '-' . $value['form'] . '-edit-' . $key,
            '#limit_validation_errors' => array($form_parents),
            '#submit' => array(),
            '#ajax' => array(
              'callback' => 'commerce_ipf_widget_refresh',
              'wrapper' => $wrapper,
            ),
          );
          $form['actions']['ipf_' . $value['form'] . '_cancel'] = array(
            '#type' => 'submit',
            '#value' => t('Cancel'),
            '#name' => 'ipf-' . $parents_delta[$parents_key] . '-' . $value['form'] . '-cancel-' . $key,
            '#limit_validation_errors' => array(),
            '#submit' => array(),
            '#ajax' => array(
              'callback' => 'commerce_ipf_widget_refresh',
              'wrapper' => $wrapper,
            ),
          );
        }
        elseif ($value['form'] == 'delete') {
          $form += commerce_ipf_commerce_product_delete_form($form, $form_state, $form_parents, $entity);

          $form['actions']['ipf_delete_confirm'] = array(
            '#type' => 'submit',
            '#value' => t('Delete'),
            '#name' => 'ipf-' . $parents_delta[$parents_key] . '-delete-confirm-' . $key,
            '#limit_validation_errors' => array(),
            '#submit' => array(),
            '#ajax' => array(
              'callback' => 'commerce_ipf_widget_refresh',
              'wrapper' => $wrapper,
            ),
          );
          $form['actions']['ipf_delete_cancel'] = array(
            '#type' => 'submit',
            '#value' => t('Cancel'),
            '#name' => 'ipf-' . $parents_delta[$parents_key] . '-delete-cancel-' . $key,
            '#limit_validation_errors' => array(),
            '#submit' => array(),
            '#ajax' => array(
              'callback' => 'commerce_ipf_widget_refresh',
              'wrapper' => $wrapper,
            ),
          );
        }
      }
      else {
        // Otherwise add the entity data for the table row.
        $row = &$element['entities'][$key];
        $row['#table_row'] = $entity_table['#rows'][$key];

        // Add an actions container with edit and delete buttons for the entity.
        $row['actions'] = array(
          '#type' => 'container',
          '#attributes' => array('class' => array('commerce-ipf-entity-operations')),
        );
        $row['actions']['ipf_entity_edit'] = array(
          '#type' => 'submit',
          '#value' => t('Edit'),
          '#name' => 'ipf-' . $parents_delta[$parents_key] . '-entity-edit-' . $key,
          '#limit_validation_errors' => array(),
          '#submit' => array(),
          '#ajax' => array(
            'callback' => 'commerce_ipf_widget_refresh',
            'wrapper' => $wrapper,
          ),
        );
        $row['actions']['ipf_entity_delete'] = array(
          '#type' => 'submit',
          '#value' => t('Delete'),
          '#name' => 'ipf-' . $parents_delta[$parents_key] . '-entity-delete-' . $key,
          '#limit_validation_errors' => array(),
          '#submit' => array(),
          '#ajax' => array(
            'callback' => 'commerce_ipf_widget_refresh',
            'wrapper' => $wrapper,
          ),
        );
      }
    }

    $element['actions'] = array(
      '#attributes' => array('class' => array('container-inline')),
      '#type' => 'container',
      '#weight' => 100,
    );
    if (commerce_ipf_widget_form_action_allow_action($form_state['commerce_ipf'][$parents_key]['action'], 'ipf_add')) {
      // Let the user select the bundle, if multiple are available.
      if (count($settings['bundles']) > 1) {
        $bundles = array();
        $info = entity_get_info($settings['entity_type']);
        foreach ($info['bundles'] as $bundle_name => $bundle_info) {
          if (in_array($bundle_name, $settings['bundles'])) {
            $bundles[$bundle_name] = $bundle_info['label'];
          }
        }

        $element['actions']['bundle'] = array(
          '#type' => 'select',
          '#options' => $bundles,
        );
      }
      else {
        $element['actions']['bundle'] = array(
          '#type' => 'value',
          '#value' => reset($settings['bundles']),
        );
      }

      $element['actions']['ipf_add'] = array(
        '#type' => 'submit',
        '#value' => t('Add a new product'),
        '#name' => 'ipf-' . $parents_delta[$parents_key] . '-add',
        '#limit_validation_errors' => array(),
        '#submit' => array(),
        '#ajax' => array(
          'callback' => 'commerce_ipf_widget_refresh',
          'wrapper' => $wrapper,
        ),
      );
    }

    $element += array(
      '#tree' => TRUE,
      '#element_validate' => array('commerce_ipf_product_form_element_validate'),
    );

    return $element;
  }
}

/**
 * Validate callback: validates the element array of an inline product form.
 */
function commerce_ipf_product_form_element_validate($element, &$form_state, $form) {
  // Extract the name of the triggering element from the form state array.
  $triggering_element_name = end($form_state['triggering_element']['#array_parents']);

  // Abort validation if the form has been rebuilt by an unknown element, such
  // as a field widget inside the embedded form.
  if (!empty($form_state['triggering_element']['#ajax']) && !in_array($triggering_element_name, array_keys(commerce_ipf_widget_form_actions()))) {
    return;
  }

  // Build a parents array for this element's values in the form.
  $parents = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language']));
  $parents_key = strtr(implode('-', $parents), '_', '-');
  $settings = $form_state['commerce_ipf'][$parents_key]['settings'];

  // Loop over the submitted delta values and update the weight of the entities
  // in the form state.
  foreach (element_children($element['entities']) as $key) {
    $form_state['commerce_ipf'][$parents_key]['entities'][$key]['weight'] = $element['entities'][$key]['delta']['#value'];
  }

  // If it was one of our widget's action buttons...
  if (in_array($triggering_element_name, array_keys(commerce_ipf_widget_form_actions()))) {
    // Extract the triggering element's delta value from the array if available.
    $triggering_element_delta = commerce_ipf_widget_form_action_delta_value($triggering_element_name, $form_state['triggering_element']['#array_parents']);

    // Stash the triggering element's name in form state and rebuild the form.
    $form_state['commerce_ipf'][$parents_key]['action'] = $triggering_element_name;
    $form_state['rebuild'] = TRUE;

    // Get the current form values.
    $form_values = drupal_array_get_nested_value($form_state['values'], $parents);

    // If the add button was submitted...
    if ($triggering_element_name == 'ipf_add' || empty($form_state['commerce_ipf'][$parents_key]['entities'])) {
      if (empty($form_state['commerce_ipf'][$parents_key]['entities'])) {
        $weight = 0;
      }
      else {
        $weight = max(array_keys($form_state['commerce_ipf'][$parents_key]['entities'])) + 1;
      }

      // Add a new entity to the form state array.
      $bundle = $form_values['actions']['bundle'];
      $info = entity_get_info($settings['entity_type']);
      $bundle_key = $info['entity keys']['bundle'];
      $default_values = array();
      // If the bundle key exists, it must always be set on an entity.
      if (!empty($bundle_key)) {
        $default_values[$bundle_key] = $bundle;
      }
      $form_state['commerce_ipf'][$parents_key]['entities'][] = array(
        'data' => entity_create($settings['entity_type'], $default_values),
        'weight' => $weight,
        'form' => 'add',
      );
    }
    elseif ($triggering_element_delta !== FALSE) {
      // An entity form has been submitted, validate it.
      if ($triggering_element_name == 'ipf_add_save' || $triggering_element_name == 'ipf_edit_save') {
        module_load_include('inc', 'commerce_ipf', 'includes/commerce_product.forms');

        $entity = &$form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['data'];
        $entity_form = $element['entities'][$triggering_element_delta]['form'];
        $entity_form_parents = array_merge($parents, array('entities', $triggering_element_delta, 'form'));
        commerce_ipf_commerce_product_form_validate($entity_form, $form_state, $entity_form_parents, $entity);

        // No errors found, proceed to submit.
        if (!form_get_errors()) {
          commerce_ipf_commerce_product_form_submit($entity_form, $form_state, $entity_form_parents, $entity);
        }
      }

      // Otherwise if we got a valid triggering element delta value, update the
      // form state entities array based on the selected action.
      switch ($triggering_element_name) {
        case 'ipf_add_save':
          $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['form'] = NULL;
          break;

        case 'ipf_add_cancel':
          unset($form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]);
          break;

        case 'ipf_entity_edit':
          $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['form'] = 'edit';
          break;

        case 'ipf_edit_save':
          $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['needs_save'] = TRUE;
          $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['form'] = NULL;
          break;

        case 'ipf_edit_cancel':
          $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['form'] = NULL;
          break;

        case 'ipf_entity_delete':
          $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['form'] = 'delete';
          break;

        case 'ipf_delete_confirm':
          $entity_id = entity_id($settings['entity_type'], $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['data']);
          if (!empty($entity_id)) {
            $form_state['commerce_ipf'][$parents_key]['delete'][] = $entity_id;
          }

          unset($form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]);
          break;

        case 'ipf_delete_cancel':
          $form_state['commerce_ipf'][$parents_key]['entities'][$triggering_element_delta]['form'] = NULL;
          break;
      }
    }
  }

  // After the refresh, include this element's values in a faux value array for
  // the field to communicate it to hook_field_attach_submit().
  form_set_value($element, array(array($settings['column'] => 0, 'commerce_ipf' => $form_state['commerce_ipf'][$parents_key])), $form_state);
}

/**
 * Implements hook_field_attach_submit().
 */
function commerce_ipf_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  $bundle_name = field_extract_bundle($entity_type, $entity);

  foreach (field_info_instances($entity_type, $bundle_name) as $instance_name => $instance) {
    if ($instance['widget']['type'] == 'commerce_inline_product_form') {
      $field_name = $instance['field_name'];
      $field = field_info_field($field_name);
      $langcode = entity_metadata_field_get_language($entity_type, $entity, $field);
      $path = array_merge($form['#parents'], array($field_name, $langcode));
      $values = drupal_array_get_nested_value($form_state['values'], $path, $key_exists);
      $settings = $values[0]['commerce_ipf']['settings'];
      // Delete any entities staged for deletion.
      if (!empty($values[0]['commerce_ipf']['delete'])) {
        entity_delete_multiple($settings['entity_type'], array_values($values[0]['commerce_ipf']['delete']));
      }

      // Respect the entity weights.
      uasort($values[0]['commerce_ipf']['entities'], 'drupal_sort_weight');
      // Go through the ipf data and assemble a list of ids.
      $entity_ids = array();
      foreach ($values[0]['commerce_ipf']['entities'] as $item) {
        if ($item['needs_save']) {
          entity_save($settings['entity_type'], $item['data']);
        }
        $entity_ids[] = array($settings['column'] => entity_id($settings['entity_type'], $item['data']));
      }
      // Set the list of ids as the field value.
      $entity->{$field_name}[$langcode] = $entity_ids;
    }
  }
}

/**
 * Refreshes the inline form widget when one of its submit buttons is clicked.
 */
function commerce_ipf_widget_refresh($form, $form_state) {
  // Extract the array parents from the triggering element to determine if one
  // of our submit buttons was clicked and at what depth in the widget's element
  // array it is.
  $array_parents = $form_state['triggering_element']['#array_parents'];
  $action = array_pop($array_parents);

  if ($array_depth = commerce_ipf_widget_form_action_array_depth($action)) {
    // Pop off the necessary number of parents so the array parents array only
    // contains the parents leading to the actual reference field.
    for ($i = 0; $i < $array_depth - 1; $i++) {
      array_pop($array_parents);
    }

    // Traverse the form array to find and return just the reference field's
    // element array.
    foreach ($array_parents as $key) {
      $form = $form[$key];
    }

    return $form[$form['#language']];
  }
}

/**
 * Themes the table showing existing entity references in the widget.
 *
 * @param $variables
 *   Contains the form element data from $element['entities'].
 */
function theme_commerce_ipf_entity_table($variables) {
  $form = $variables['form'];

  $header = array(
    array('data' => '', 'class' => array('ipf-tabledrag-header')),
    array('data' => t('Sort order'), 'class' => array('ipf-sort-order-header')),
  );
  // Add headers provided by the IPF table callback.
  $header = array_merge($header, $form['#table_header']);
  $header[] = t('Operations');

  // Build an array of entity rows for the table.
  $rows = array();

  foreach (element_children($form) as $key) {
    // If the current entity array specifies a form, output that in a multi-
    // column cell in the table.
    if (!empty($form[$key]['form'])) {
      $row = array(
        array('data' => '', 'class' => array('ipf-tabledrag-handle')),
        drupal_render($form[$key]['delta']),
        array('data' => drupal_render($form[$key]['form']), 'colspan' => 3),
      );
    }
    else {
      // Otherwise output all the entity data in the table.
      $row = array(
        array('data' => '', 'class' => array('ipf-tabledrag-handle')),
        drupal_render($form[$key]['delta']),
      );
      // Add cells provided by the IPF table callback.
      $row = array_merge($row, $form[$key]['#table_row']);
      $row[] = drupal_render($form[$key]['actions']);
    }

    $rows[] = array('data' => $row, 'class' => array('draggable'));
  }

  if (!empty($rows)) {
    // Add the tabledrag JavaScript.
    drupal_add_tabledrag('commerce-ipf-entity-table', 'order', 'sibling', 'commerce-ipf-entity-delta');

    // Return the themed table.
    return theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'commerce-ipf-entity-table')));
  }
}

/**
 * Implements hook_field_widget_error().
 */
function commerce_ipf_field_widget_error($element, $error) {
  form_error($element, $error['message']);
}

/**
 * Returns an array of widget form action info keyed by button name.
 */
function commerce_ipf_widget_form_actions() {
  return array(
    'ipf_add' => array(
      'array_depth' => 3,
      'allowed_actions' => array(),
    ),
    'ipf_add_save' => array(
      'array_depth' => 6,
      'delta_depth' => 3,
      'allowed_actions' => array('ipf_add'),
    ),
    'ipf_add_cancel' => array(
      'array_depth' => 6,
      'delta_depth' => 3,
      'allowed_actions' => array('ipf_add'),
    ),
    'ipf_entity_edit' => array(
      'array_depth' => 5,
      'delta_depth' => 2,
      'allowed_actions' => array(),
    ),
    'ipf_edit_save' => array(
      'array_depth' => 6,
      'delta_depth' => 3,
      'allowed_actions' => array('ipf_add'),
    ),
    'ipf_edit_cancel' => array(
      'array_depth' => 6,
      'delta_depth' => 3,
      'allowed_actions' => array('ipf_add'),
    ),
    'ipf_entity_delete' => array(
      'array_depth' => 5,
      'delta_depth' => 2,
      'allowed_actions' => array(),
    ),
    'ipf_delete_confirm' => array(
      'array_depth' => 6,
      'delta_depth' => 3,
      'allowed_actions' => array('ipf_add'),
    ),
    'ipf_delete_cancel' => array(
      'array_depth' => 6,
      'delta_depth' => 3,
      'allowed_actions' => array('ipf_add'),
    ),
  );
}

/**
 * Returns the array depth of a given action.
 *
 * @param $action
 *   The name of the submit button element on the inline product form widget.
 *
 * @return
 *   The array depth of the given button from the root widget form element.
 */
function commerce_ipf_widget_form_action_array_depth($action) {
  $actions = commerce_ipf_widget_form_actions();

  if (!empty($actions[$action])) {
    return $actions[$action]['array_depth'];
  }

  return FALSE;
}

/**
 * Returns the delta value for the product a targeted action was performed on.
 *
 * @param $action
 *   The name of the targeted action performed on a product.
 * @param $array_parents
 *   The #parents array of the submit button used to perform the action.
 *
 * @return
 *   The delta value in the widget's element array for the targeted product or
 *   FALSE if it could not be found.
 */
function commerce_ipf_widget_form_action_delta_value($action, $array_parents) {
  $actions = commerce_ipf_widget_form_actions();

  if (!empty($actions[$action]['delta_depth'])) {
    $delta_depth = $actions[$action]['delta_depth'];
  }
  else {
    return FALSE;
  }

  for ($i = 0; $i < $delta_depth; $i++) {
    array_pop($array_parents);
  }

  return end($array_parents);
}

/**
 * Returns a boolean indicating whether a particular action is allowed when the
 * specified action has been used.
 *
 * @param $action
 *   The name of the submit button element on the inline product form widget.
 * @param $target_action
 *   The name of the secondary action you want to check for access to when the
 *   action has been performed.
 *
 * @return
 *   TRUE or FALSE indicating whether or not the action is allowed.
 */
function commerce_ipf_widget_form_action_allow_action($action, $target_action) {
  // Allow any target action if no action has been performed yet.
  if (empty($action)) {
    return TRUE;
  }

  // Extract the array of allowed follow-up actions from the current action.
  $actions = commerce_ipf_widget_form_actions();
  $allowed_actions = !empty($actions[$action]['allowed_actions']) ? $actions[$action]['allowed_actions'] : array();

  return in_array($target_action, $allowed_actions);
}
