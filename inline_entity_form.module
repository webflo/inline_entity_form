<?php

/**
 * @file
 * Provides a widget for inline management (creation, modification, removal) of
 * referenced entities. The primary use case is the parent -> children one
 * (for example, order -> line items), where the child entities are never
 * managed outside the parent form.
 */

/**
 * Implements hook_entity_info_alter().
 */
function inline_entity_form_entity_info_alter(&$entity_info) {
  $entity_info['commerce_product']['inline entity form'] = array(
    'controller' => 'CommerceProductInlineEntityFormController',
  );
  $entity_info['commerce_line_item']['inline entity form'] = array(
    'controller' => 'CommerceLineItemInlineEntityFormController',
  );
}

/**
 * Attaches theme specific CSS files.
 *
 * @param $theme_css
 *  An array of all CSS files that should be considered.
 * @param $css
 *   The $form['#attached']['css'] array, modified by reference.
 */
function _inline_entity_form_attach_css($theme_css, &$css) {
  if (empty($theme_css)) {
    return;
  }

  // Add the base CSS file, if provided.
  if (!empty($theme_css['base'])) {
    $css[] = $theme_css['base'];
  }

  // Add the theme specific CSS file, if provided.
  $theme_key = $GLOBALS['theme'];
  if (!empty($theme_css[$theme_key])) {
    $css[] = $theme_css[$theme_key];
  }
}

/**
 * Implements hook_theme().
 */
function inline_entity_form_theme() {
  return array(
    'inline_entity_form_entity_table' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_field_widget_info().
 */
function inline_entity_form_field_widget_info() {
  $widgets = array();

  $widgets['inline_entity_form'] = array(
    'label' => t('Inline entity form'),
    'field types' => array('commerce_line_item_reference', 'commerce_product_reference', 'entityreference'),
    'settings' => array(
      'fields' => array(),
      'type_settings' => array(),
    ),
    'behaviors' => array(
      'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      'default value' => FIELD_BEHAVIOR_NONE,
    ),
  );

  return $widgets;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function inline_entity_form_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  $ief_settings = inline_entity_form_settings($field, $instance);
  $entity_info = entity_get_info($ief_settings['entity_type']);
  // The current entity type is not supported, execution can't continue.
  if (!isset($entity_info['inline entity form'])) {
    return array();
  }

  $element = array();
  // The fields are not editable from the UI for now.
  $element['fields'] = array(
    '#type' => 'value',
    '#value' => $settings['fields'],
  );

  // Add entity type specific settings if they exist.
  $controller = new $entity_info['inline entity form']['controller']($ief_settings['entity_type'], $settings['type_settings']);
  $settings_form = $controller->settingsForm($field, $instance);
  if (!empty($settings_form)) {
    $element['type_settings'] = array(
      '#type' => 'fieldset',
      '#title' => t('Inline Entity Form: %type', array('%type' => $entity_info['label'])),
    );
    $element['type_settings'] += $settings_form;
  }

  return $element;
}

/**
 * Introspects field and instance settings, and determines the correct settings
 * for the functioning of the widget.
 *
 * Settings:
 *   - entity_type - The entity_type being managed.
 *   - bundles - Bundles of entities that the user is allowed to create.
 *   - column - The name of the ref. field column that stores the entity id.
 */
function inline_entity_form_settings($field, $instance) {
  $settings = array(
    'entity_type' => NULL,
    'bundles' => array(),
    'column' => NULL,
  );

  if ($field['type'] == 'commerce_product_reference') {
    $settings['entity_type'] = 'commerce_product';
    $settings['column'] = 'product_id';

    // The product reference field has its bundle setting, use it.
    $types = array_filter($instance['settings']['referenceable_types']);
    if (!empty($types)) {
      $settings['bundles'] = array_values($types);
    }
  }
  elseif ($field['type'] == 'entityreference') {
    $settings['entity_type'] = $field['settings']['target_type'];
    $settings['column'] = 'target_id';

    if (!empty($field['settings']['handler_settings']['target_bundles'])) {
      $bundles = array_filter($field['settings']['handler_settings']['target_bundles']);
      if (!empty($bundles)) {
        $settings['bundles'] = array_values($bundles);
      }
    }
  }
  elseif ($field['type'] == 'commerce_line_item_reference') {
    $settings['entity_type'] = 'commerce_line_item';
    $settings['column'] = 'line_item_id';
  }

  // By default, allow entities of all bundles to be created.
  if (empty($settings['bundles'])) {
    $info = entity_get_info($settings['entity_type']);
    foreach ($info['bundles'] as $bundle_name => $bundle_info) {
      $settings['bundles'][] = $bundle_name;
    }
  }

  return $settings;
}

/**
 * Implements hook_field_widget_form().
 */
function inline_entity_form_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $widget = $instance['widget'];
  $settings = inline_entity_form_settings($field, $instance);
  $entity_info = entity_get_info($settings['entity_type']);
  $type_settings = $widget['settings']['type_settings'];
  // The current entity type is not supported, execution can't continue.
  if (!isset($entity_info['inline entity form'])) {
    return array();
  }

  // Instantiate the inline entity form controller for the current entity type.
  $controller = new $entity_info['inline entity form']['controller']($settings['entity_type'], $type_settings);
  // Get the entity type labels for the UI strings.
  $labels = $controller->labels();

  // Build a parents array for this element's values in the form.
  $parents = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language']));

  // Assign a unique identifier to each IEF widget.
  $ief_id = $instance['id'];
  // Determine the wrapper ID for the entire element.
  $wrapper = 'inline-entity-form-' . $ief_id;
  $element = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#description' => NULL,
    '#prefix' => '<div id="' . $wrapper . '">',
    '#suffix' => '</div>',
    '#attached' => array(
      'css' => array(),
      'js' => array(
        // Give the JS file a weight so that it runs after file.js.
        drupal_get_path('module', 'inline_entity_form') . '/inline_entity_form.js' => array('weight' => 10),
      ),
    ),
    '#ief_id' => $ief_id,
    '#ief_root' => TRUE,
  ) + $element;

  $base_css = array(
    'base' => drupal_get_path('module', 'inline_entity_form') . '/theme/inline_entity_form.css',
    'seven' => drupal_get_path('module', 'inline_entity_form') . '/theme/inline_entity_form.seven.css',
  );
  // Add the base module CSS.
  _inline_entity_form_attach_css($base_css, $element['#attached']['css']);
  // Add entity type specific CSS.
  _inline_entity_form_attach_css($controller->css(), $element['#attached']['css']);

  // Initialize the IEF array in form state.
  if (empty($form_state['inline_entity_form'][$ief_id])) {
    $form_state['inline_entity_form'][$ief_id] = array(
      'form' => NULL,
      'settings' => $settings,
      'type_settings' => $type_settings,
    );

    // Load the entities from the $items array and store them in the form
    // state for further manipulation.
    $form_state['inline_entity_form'][$ief_id]['entities'] = array();
    $entity_ids = array();
    foreach ($items as $item) {
      $entity_ids[] = $item[$settings['column']];
    }

    $delta = 0;
    foreach (entity_load($settings['entity_type'], $entity_ids) as $entity) {
      $form_state['inline_entity_form'][$ief_id]['entities'][$delta] = array(
        'entity' => $entity,
        'weight' => $delta,
        'form' => NULL,
        'needs_save' => FALSE,
      );

      $delta++;
    }

    // If no entities were found, try to open the add form.
    if (empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
      if (count($settings['bundles']) == 1) {
        $form_state['inline_entity_form'][$ief_id]['form'] = 'add';
        $form_state['inline_entity_form'][$ief_id]['form settings'] = array(
          'bundle' => reset($settings['bundles']),
        );
      }
    }
  }

  // If the reference field must always have one entity of a specific type,
  // provide a simplified widget that shows the entity form inline, without any
  // actions. Otherwise, show the full complex widget.
  if ($field['cardinality'] == 1 && $instance['required'] && count($settings['bundles']) == 1) {
    $element['form'] = array(
      '#type' => 'container',
      '#op' => 'add',
      // Used by Field API and controller methods to find the relevant
      // values in $form_state.
      '#parents' => array_merge($parents, array('form')),
      // Pass the current entity type.
      '#entity_type' => $settings['entity_type'],
      // Identifies the IEF widget to which the form belongs.
      '#ief_id' => $ief_id,
    );
    if (!empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
      $element['#op'] = 'edit';
      $element['form']['entity'] = $form_state['inline_entity_form'][$ief_id]['entities'][0]['entity'];
      $element['form']['#ief_row_delta'] = 0;
    }

    $element['form'] = inline_entity_form_entity_form($controller, $element['form'], $form_state);
    // Hide all actions, the widget form behaves like a part of the main form.
    $element['form']['actions']['#access'] = FALSE;
  }
  else {
    $element['#element_validate'] = array('inline_entity_form_save_row_weights');
    // Add description text to the widget.
    if (empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
      $element['#description'] = t('No @type_plural have been created.', array('@type_plural' => $labels['plural']));
      if ($instance['required']) {
        $element['#description'] .= ' ' . t('At least one @type_singular is required.', array('@type_singular' => $labels['singular']));
      }
    }

    $element['entities'] = array(
      '#tree' => TRUE,
      '#theme' => 'inline_entity_form_entity_table',
      '#entity_type' => $settings['entity_type'],
    );
    // Get the fields that should be displayed in the table.
    // They can either come from the widget settings or from a "default fields"
    // callback.
    if (!empty($widget['settings']['fields'])) {
      $element['entities']['#fields'] = $widget['settings']['fields'];
    }
    else {
      $element['entities']['#fields'] = $controller->defaultFields($settings['bundles']);
    }

    foreach ($form_state['inline_entity_form'][$ief_id]['entities'] as $key => $value) {
      // Data used by theme_inline_entity_form_entity_table().
      $element['entities'][$key]['#entity'] = $entity = $value['entity'];
      $element['entities'][$key]['#needs_save'] = $value['needs_save'];

      // Handle row weights.
      $element['entities'][$key]['#weight'] = $value['weight'];

      // First check to see if this entity should be displayed as a form.
      if (!empty($value['form'])) {
        $element['entities'][$key]['delta'] = array(
          '#type' => 'value',
          '#value' => $value['weight'],
        );
        $element['entities'][$key]['form'] = array(
          '#type' => 'container',
          '#attributes' => array('class' => array('inline-entity-form-title')),
          '#op' => $value['form'],
          // Used by Field API and controller methods to find the relevant
          // values in $form_state.
          '#parents' => array_merge($parents, array('entities', $key, 'form')),
          // Store the entity on the form, later modified in the controller.
          '#entity' => $entity,
          '#entity_type' => $settings['entity_type'],
          // Identifies the IEF widget to which the form belongs.
          '#ief_id' => $ief_id,
          // Identifies the table row to which the form belongs.
          '#ief_row_delta' => $key,
        );
        // Prepare data for the form callbacks.
        $form = &$element['entities'][$key]['form'];

        // Add the appropriate form.
        if ($value['form'] == 'edit') {
          $form += inline_entity_form_entity_form($controller, $form, $form_state);
        }
        elseif ($value['form'] == 'delete') {
          $form += inline_entity_form_delete_form($controller, $form, $form_state);
        }
      }
      else {
        $row = &$element['entities'][$key];
        $row['delta'] = array(
          '#type' => 'weight',
          '#delta' => 50,
          '#default_value' => $value['weight'],
          '#attributes' => array('class' => array('ief-entity-delta')),
        );
        // Add an actions container with edit and delete buttons for the entity.
        $row['actions'] = array(
          '#type' => 'container',
          '#attributes' => array('class' => array('ief-entity-operations')),
        );
        $row['actions']['ief_entity_edit'] = array(
          '#type' => 'submit',
          '#value' => t('Edit'),
          '#name' => 'ief-' . $ief_id . '-entity-edit-' . $key,
          '#limit_validation_errors' => array(),
          '#ajax' => array(
            'callback' => 'inline_entity_form_get_element',
            'wrapper' => $wrapper,
          ),
          '#submit' => array('inline_entity_form_open_row_form'),
          '#ief_row_delta' => $key,
          '#ief_row_form' => 'edit',
        );
        $row['actions']['ief_entity_delete'] = array(
          '#type' => 'submit',
          '#value' => t('Delete'),
          '#name' => 'ief-' . $ief_id . '-entity-delete-' . $key,
          '#limit_validation_errors' => array(),
          '#ajax' => array(
            'callback' => 'inline_entity_form_get_element',
            'wrapper' => $wrapper,
          ),
          '#submit' => array('inline_entity_form_open_row_form'),
          '#ief_row_delta' => $key,
          '#ief_row_form' => 'delete',
        );
      }
    }

    // If no form is open, show buttons that open one.
    if (empty($form_state['inline_entity_form'][$ief_id]['form'])) {
      $element['actions'] = array(
        '#attributes' => array('class' => array('container-inline')),
        '#type' => 'container',
        '#weight' => 100,
      );

      // Let the user select the bundle, if multiple are available.
      if (count($settings['bundles']) > 1) {
        $bundles = array();
        foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
          if (in_array($bundle_name, $settings['bundles'])) {
            $bundles[$bundle_name] = $bundle_info['label'];
          }
        }

        $element['actions']['bundle'] = array(
          '#type' => 'select',
          '#options' => $bundles,
        );
      }
      else {
        $element['actions']['bundle'] = array(
          '#type' => 'value',
          '#value' => reset($settings['bundles']),
        );
      }

      $element['actions']['ief_add'] = array(
        '#type' => 'submit',
        '#value' => t('Add a new @type_singular', array('@type_singular' => $labels['singular'])),
        '#name' => 'ief-' . $ief_id . '-add',
        '#limit_validation_errors' => array(array_merge($parents, array('actions'))),
        '#ajax' => array(
          'callback' => 'inline_entity_form_get_element',
          'wrapper' => $wrapper,
        ),
        '#submit' => array('inline_entity_form_open_form'),
        '#ief_form' => 'add',
      );
    }
    else {
      // There's a form open, show it.
      $element['form'] = array(
        '#type' => 'fieldset',
        // Identifies the IEF widget to which the form belongs.
        '#ief_id' => $ief_id,
        // Used by Field API and controller methods to find the relevant
        // values in $form_state.
        '#parents' => array_merge($parents, array('form')),
        // Pass the current entity type.
        '#entity_type' => $settings['entity_type'],
      );

      if ($form_state['inline_entity_form'][$ief_id]['form'] == 'add') {
        $element['form']['#op'] = 'add';
        $element['form'] += inline_entity_form_entity_form($controller, $element['form'], $form_state);

        // Hide the cancel button if the reference field is required but
        // contains no values. That way the user is forced to create an entity.
        if ($instance['required'] && empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
          $element['form']['actions']['ief_add_cancel']['#access'] = FALSE;
        }
      }
    }
  }

  // Mark the parent form submit button with a special flag that will trigger
  // a save of inline forms and entity weights.
  $form['actions']['submit']['#ief_submit_all'] = TRUE;

  return $element;
}

/**
 * Wraps and returns the entity form provided by the passed-in controller.
 *
 * @param $controller
 *   The inline entity form controller.
 * @param $entity_form
 *   The form array that will receive the entity form.
 * @param $form_state
 *   The form state of the parent form.
 *
 * @return
 *   The form array containing the embedded entity form.
 */
function inline_entity_form_entity_form($controller, $entity_form, &$form_state) {
  $labels = $controller->labels();
  // Build a deta suffix that's appended to button #name keys for uniqueness.
  $delta = $entity_form['#ief_id'];
  if ($entity_form['#op'] == 'edit') {
    $delta .= '-' . $entity_form['#ief_row_delta'];
  }
  elseif ($entity_form['#op'] == 'add') {
    // Create a new entity that will be passed to the form.
    $form_settings = $form_state['inline_entity_form'][$entity_form['#ief_id']]['form settings'];
    $entity_form['#entity'] = inline_entity_form_create_entity($entity_form['#entity_type'], $form_settings['bundle']);
    $entity_form['#title'] = t('Add new @type_singular', array('@type_singular' => $labels['singular']));
  }

  // Retrieve the form provided by the controller.
  $entity_form = $controller->entityForm($entity_form, $form_state);
  // Add the actions
  $entity_form['actions'] = array(
    '#type' => 'container',
    '#weight' => 100,
  );
  $entity_form['actions']['ief_' . $entity_form['#op'] . '_save'] = array(
    '#type' => 'submit',
    '#value' => t('Save @type_singular', array('@type_singular' => $labels['singular'])),
    '#name' => 'ief-' . $entity_form['#op'] . '-submit-' . $delta,
    '#limit_validation_errors' => array($entity_form['#parents']),
    '#attributes' => array('class' => array('ief-entity-submit')),
    '#ajax' => array(
      'callback' => 'inline_entity_form_get_element',
      'wrapper' => 'inline-entity-form-' . $entity_form['#ief_id'],
    ),
  );
  $entity_form['actions']['ief_' . $entity_form['#op'] . '_cancel'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#name' => 'ief-' . $entity_form['#op'] . '-cancel-' . $delta,
    '#limit_validation_errors' => array(),
    '#ajax' => array(
      'callback' => 'inline_entity_form_get_element',
      'wrapper' => 'inline-entity-form-' . $entity_form['#ief_id'],
    ),
  );

  // Add the appropriate submit handlers and their related data.
  if ($entity_form['#op'] == 'add') {
    $entity_form['actions']['ief_add_save']['#submit'] = array('inline_entity_form_close_form');
    $entity_form['actions']['ief_add_cancel']['#submit'] = array('inline_entity_form_close_form');
  }
  else {
    $entity_form['actions']['ief_edit_save']['#submit'] = array('inline_entity_form_close_row_form');
    $entity_form['actions']['ief_edit_save']['#ief_row_delta'] = $entity_form['#ief_row_delta'];
    $entity_form['actions']['ief_edit_cancel']['#submit'] = array('inline_entity_form_close_row_form');
    $entity_form['actions']['ief_edit_cancel']['#ief_row_delta'] = $entity_form['#ief_row_delta'];
  }

  // Add the validation callback that calls the controller's
  // entityFormValidate() and entityFormSubmit() methods.
  // Implemented as #element_validate so that entity forms are submitted
  // when the parent form is submitted.
  $entity_form['#element_validate'][] = 'inline_entity_form_process_entity_form';
  // Add the pre_render callback that powers the #fieldset form element key,
  // which moves the element to the specified fieldset without modifying its
  // position in $form_state['values'].
  $entity_form['#pre_render'][] = 'inline_entity_form_pre_render_add_fieldset_markup';

  return $entity_form;
}

/**
 * Processes an entity form submission.
 *
 * The entity form is first validated by its controller.
 * If no errors were set, the controller's submit method is then called,
 * which modifies the entity stored in $entity_form['#entity'] and prepares
 * it for saving.
 *
 * @param $entity_form
 *  The form of the entity being managed inline.
 * @param $form_state
 *   The form state of the parent form.
 */
function inline_entity_form_process_entity_form(&$entity_form, &$form_state) {
  // Only react on submissions triggered by the main submit buttons.
  $triggering_element_name = end($form_state['triggering_element']['#array_parents']);
  if (empty($form_state['triggering_element']['#ief_submit_all']) && !in_array($triggering_element_name, array('ief_add_save', 'ief_edit_save'))) {
    return;
  }

  $entity_type = $entity_form['#entity_type'];
  $entity_info = entity_get_info($entity_type);
  $ief_id = $entity_form['#ief_id'];
  $type_settings = $form_state['inline_entity_form'][$ief_id]['type_settings'];

  // Instantiate the controller and validate the form.
  $controller = new $entity_info['inline entity form']['controller']($entity_type, $type_settings);
  $controller->entityFormValidate($entity_form, $form_state);

  // If validation passed, execute the submission handler.
  if (!form_get_errors()) {
    $controller->entityFormSubmit($entity_form, $form_state);
    $entity = $entity_form['#entity'];

    if ($entity_form['#op'] == 'add') {
      // Determine the correct weight of the new element.
      $weight = 0;
      if (!empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
        $weight = max(array_keys($form_state['inline_entity_form'][$ief_id]['entities'])) + 1;
      }
      // Add the entity to form state, mark it for saving, and close the form.
      $form_state['inline_entity_form'][$ief_id]['entities'][] = array(
        'entity' => $entity_form['#entity'],
        'weight' => $weight,
        'form' => NULL,
        'needs_save' => TRUE,
      );
    }
    else {
      $delta = $entity_form['#ief_row_delta'];
      $form_state['inline_entity_form'][$ief_id]['entities'][$delta]['entity'] = $entity_form['#entity'];
      $form_state['inline_entity_form'][$ief_id]['entities'][$delta]['needs_save'] = TRUE;
    }
  }
}

/**
 * Wraps and returns the delete form provided by the passed-in controller.
 *
 * @param $controller
 *   The inline entity form controller.
 * @param $delete_form
 *   The form array that will receive the entity form.
 * @param $form_state
 *   The form state of the parent form.
 *
 * @return
 *   The form array containing the embedded delete form.
 */
function inline_entity_form_delete_form($controller, $delete_form, &$form_state) {
  // Build a deta suffix that's appended to button #name keys for uniqueness.
  $delta = $delete_form['#ief_id'] . '-' . $delete_form['#ief_row_delta'];

  // Retrieve the form provided by the controller.
  $delete_form = $controller->deleteForm($delete_form, $form_state);
  // Add the actions
  $delete_form['actions'] = array(
    '#type' => 'container',
    '#weight' => 100,
  );
  $delete_form['actions']['ief_delete_confirm'] = array(
    '#type' => 'submit',
    '#value' => t('Delete'),
    '#name' => 'ief-delete-confirm-' . $delta,
    '#limit_validation_errors' => array(),
    '#ajax' => array(
      'callback' => 'inline_entity_form_get_element',
      'wrapper' => 'inline-entity-form-' . $delete_form['#ief_id'],
    ),
    '#submit' => array('inline_entity_form_delete_confirm'),
    '#ief_row_delta' => $delete_form['#ief_row_delta'],
  );
  $delete_form['actions']['ief_delete_cancel'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#name' => 'ief-delete-cancel-' . $delta,
    '#limit_validation_errors' => array(),
    '#ajax' => array(
      'callback' => 'inline_entity_form_get_element',
      'wrapper' => 'inline-entity-form-' . $delete_form['#ief_id'],
    ),
    '#submit' => array('inline_entity_form_close_row_form'),
    '#ief_row_delta' => $delete_form['#ief_row_delta'],
  );

  return $delete_form;
}

/**
 * Button #submit callback: Marks the entity for deletion and removes the row.
 *
 * The row is identified by #ief_row_delta stored on the triggering
 * element.
 *
 * @param $form
 *   The complete parent form.
 * @param $form_state
 *   The form state of the parent form.
 */
function inline_entity_form_delete_confirm($form, &$form_state) {
  $element = inline_entity_form_get_element($form, $form_state);
  $ief_id = $element['#ief_id'];
  $delta = $form_state['triggering_element']['#ief_row_delta'];

  $form_state['rebuild'] = TRUE;
  $settings = $form_state['inline_entity_form'][$ief_id]['settings'];
  $entity_id = entity_id($settings['entity_type'], $form_state['inline_entity_form'][$ief_id]['entities'][$delta]['entity']);
  if (!empty($entity_id)) {
    $form_state['inline_entity_form'][$ief_id]['delete'][] = $entity_id;
  }
  unset($form_state['inline_entity_form'][$ief_id]['entities'][$delta]);
}

/**
 * Button #submit callback: Opens a form in the IEF widget.
 *
 * The form is shown below the entity table, at the bottom of the widget.
 *
 * @param $form
 *   The complete parent form.
 * @param $form_state
 *   The form state of the parent form.
 */
function inline_entity_form_open_form($form, &$form_state) {
  $element = inline_entity_form_get_element($form, $form_state);
  $ief_id = $element['#ief_id'];

  $form_state['rebuild'] = TRUE;
  // Get the current form values.
  $parents = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language']));
  $form_values = drupal_array_get_nested_value($form_state['values'], $parents);

  $form_state['inline_entity_form'][$ief_id]['form'] = $form_state['triggering_element']['#ief_form'];
  $form_state['inline_entity_form'][$ief_id]['form settings'] = array(
    'bundle' => $form_values['actions']['bundle'],
  );
}

/**
 * Button #submit callback: Closes a form in the IEF widget.
 *
 * @param $form
 *   The complete parent form.
 * @param $form_state
 *   The form state of the parent form.
 *
 * @see inline_entity_form_open_form().
 */
function inline_entity_form_close_form($form, &$form_state) {
  $element = inline_entity_form_get_element($form, $form_state);
  $ief_id = $element['#ief_id'];

  $form_state['rebuild'] = TRUE;
  $form_state['inline_entity_form'][$ief_id]['form'] = NULL;
}

/**
 * Button #submit callback: Opens a row form in the IEF widget.
 *
 * The row is identified by #ief_row_delta stored on the triggering
 * element.
 *
 * @param $form
 *   The complete parent form.
 * @param $form_state
 *   The form state of the parent form.
 */
function inline_entity_form_open_row_form($form, &$form_state) {
  $element = inline_entity_form_get_element($form, $form_state);
  $ief_id = $element['#ief_id'];
  $delta = $form_state['triggering_element']['#ief_row_delta'];

  $form_state['rebuild'] = TRUE;
  $form_state['inline_entity_form'][$ief_id]['entities'][$delta]['form'] = $form_state['triggering_element']['#ief_row_form'];
}

/**
 * Button #submit callback: Closes a row form in the IEF widget.
 *
 * @param $form
 *   The complete parent form.
 * @param $form_state
 *   The form state of the parent form.
 *
 * @see inline_entity_form_open_row_form().
 */
function inline_entity_form_close_row_form($form, &$form_state) {
  $element = inline_entity_form_get_element($form, $form_state);
  $ief_id = $element['#ief_id'];
  $delta = $form_state['triggering_element']['#ief_row_delta'];

  $form_state['rebuild'] = TRUE;
  $form_state['inline_entity_form'][$ief_id]['entities'][$delta]['form'] = NULL;
}

/**
 * IEF widget #element_validate callback: Saves the weights of entities.
 */
function inline_entity_form_save_row_weights($element, &$form_state, $form) {
  // Only react on the submission of the parent form.
  if (empty($form_state['triggering_element']['#ief_submit_all'])) {
    return;
  }

  $ief_id = $element['#ief_id'];
  // Loop over the submitted delta values and update the weight of the entities
  // in the form state.
  foreach (element_children($element['entities']) as $key) {
    $form_state['inline_entity_form'][$ief_id]['entities'][$key]['weight'] = $element['entities'][$key]['delta']['#value'];
  }
}

/**
 * Implements hook_field_attach_submit().
 */
function inline_entity_form_field_attach_submit($parent_entity_type, $parent_entity, $form, &$form_state) {
  list(, , $bundle_name) = entity_extract_ids($parent_entity_type, $parent_entity);

  foreach (field_info_instances($parent_entity_type, $bundle_name) as $instance_name => $instance) {
    if (isset($instance['widget']) && $instance['widget']['type'] == 'inline_entity_form') {
      $field_name = $instance['field_name'];
      $langcode = $form[$field_name]['#language'];
      $ief_id = $instance['id'];
      // There's no IEF data for this field, skip it.
      if (empty($form_state['inline_entity_form'][$ief_id])) {
        continue;
      }

      $values = $form_state['inline_entity_form'][$ief_id];
      $entity_type = $values['settings']['entity_type'];
      $entity_info = entity_get_info($entity_type);
      $controller = new $entity_info['inline entity form']['controller']($entity_type, $values['type_settings']);
      $context = array(
        'parent_entity_type' => $parent_entity_type,
        'parent_entity' => $parent_entity,
      );

      // Delete any entities staged for deletion.
      if (!empty($values['delete'])) {
        $controller->delete(array_values($values['delete']), $context);
      }

      // Respect the entity weights.
      uasort($values['entities'], 'drupal_sort_weight');
      // Go through the IEF data and assemble a list of ids.
      $entity_ids = array();
      foreach ($values['entities'] as $item) {
        if ($item['needs_save']) {
          $controller->save($item['entity'], $context);
        }
        $entity_ids[] = array($values['settings']['column'] => entity_id($entity_type, $item['entity']));
      }
      // Set the list of ids as the field value.
      $parent_entity->{$field_name}[$langcode] = $entity_ids;
    }
  }
}

/**
 * Returns an IEF widget nearest to the triggering element.
 */
function inline_entity_form_get_element($form, $form_state) {
  $element = array();
  $array_parents = $form_state['triggering_element']['#array_parents'];
  // Remove the action and the actions container.
  $array_parents = array_slice($array_parents, 0, -2);

  while (!isset($element['#ief_root'])) {
    $element = drupal_array_get_nested_value($form, $array_parents);
    array_pop($array_parents);
  }

  return $element;
}

/**
 * Creates a new entity of the given type, with the bundle key set by default.
 */
function inline_entity_form_create_entity($entity_type, $bundle = '') {
  $entity_info = entity_get_info($entity_type);
  $bundle_key = $entity_info['entity keys']['bundle'];
  $default_values = array();
  // If the bundle key exists, it must always be set on an entity.
  if (!empty($bundle_key)) {
    $default_values[$bundle_key] = $bundle;
  }

  return entity_create($entity_type, $default_values);
}

/**
 * Themes the table showing existing entity references in the widget.
 *
 * @param $variables
 *   Contains the form element data from $element['entities'].
 */
function theme_inline_entity_form_entity_table($variables) {
  $form = $variables['form'];
  $entity_type = $form['#entity_type'];
  $fields = $form['#fields'];
  // Sort the fields by weight and remove the ones that won't be displayed.
  uasort($fields, 'drupal_sort_weight');
  foreach ($fields as $field_name => $field) {
    if (empty($field['visible'])) {
      unset($fields[$field_name]);
    }
  }
  // If one of the rows is in form context, disable tabledrag.
  $has_tabledrag = TRUE;
  foreach (element_children($form) as $key) {
    if (!empty($form[$key]['form'])) {
      $has_tabledrag = FALSE;
    }
  }

  $header = array();
  if ($has_tabledrag) {
    $header[] = array('data' => '', 'class' => array('ief-tabledrag-header'));
    $header[] = array('data' => t('Sort order'), 'class' => array('ief-sort-order-header'));
  }
  // Add header columns for each field.
  $first = TRUE;
  foreach ($fields as $field_name => $field) {
    $column = array('data' => $field['label']);
    // The first column gets a special class.
    if ($first) {
      $column['class'] = array('ief-first-column-header');
      $first = FALSE;
    }
    $header[] = $column;
  }
  $header[] = t('Operations');

  // Build an array of entity rows for the table.
  $rows = array();
  foreach (element_children($form) as $key) {
    $entity = $form[$key]['#entity'];
    $entity_id = entity_id($entity_type, $entity);
    // Many field formatters (such as the ones for files and images) need
    // certain data that might be missing on unsaved entities because the field
    // load hooks haven't run yet. Because of that, those hooks are invoked
    // explicitly. This is the same trick used by node_preview().
    if ($form[$key]['#needs_save']) {
      _field_invoke_multiple('load', $entity_type, array($entity_id => $entity));
    }

    $row_classes = array('ief-row-entity');
    $cells = array();
    if ($has_tabledrag) {
      $cells[] = array('data' => '', 'class' => array('ief-tabledrag-handle'));
      $cells[] = drupal_render($form[$key]['delta']);
      $row_classes[] = 'draggable';
    }
    // Add a special class to rows that have a form underneath, to allow
    // for additional styling.
    if (!empty($form[$key]['form'])) {
      $row_classes[] = 'ief-row-entity-form';
    }

    // Add fields that represent the entity..
    foreach ($fields as $field_name => $field) {
      if ($field['type'] == 'extra_field') {
        $data = check_plain($entity->{$field_name});
      }
      elseif ($field['type'] == 'field') {
        $settings = array(
          'label' => 'hidden',
          'type' => $field['formatter'],
          'settings' => $field['settings']
        );
        $renderable_data = field_view_field($entity_type, $entity, $field_name, $settings);
        // The field has specified an exact delta to display.
        if (isset($field['delta'])) {
          if (!empty($renderable_data[$field['delta']])) {
            $renderable_data = $renderable_data[$field['delta']];
          }
          else {
            // The field has no value for the specified delta, show nothing.
            $renderable_data = array();
          }
        }
        $data = drupal_render($renderable_data);
      }

      $cells[] = array('data' => $data, 'class' => array('inline-entity-form-' . $entity_type . '-' . $field_name));
    }
    // Add the buttons belonging to the "Operations" column.
    $cells[] = drupal_render($form[$key]['actions']);
    // Create the row.
    $rows[] = array('data' => $cells, 'class' => $row_classes);

    // If the current entity array specifies a form, output it in the next row.
    if (!empty($form[$key]['form'])) {
      $row = array(
        array('data' => drupal_render($form[$key]['form']), 'colspan' => count($fields) + 1),
      );
      $rows[] = array('data' => $row, 'class' => array('ief-row-form'), 'no_striping' => TRUE);
    }
  }

  if (!empty($rows)) {
    if ($has_tabledrag) {
      // Add the tabledrag JavaScript.
      drupal_add_tabledrag('ief-entity-table', 'order', 'sibling', 'ief-entity-delta');
    }

    // Return the themed table.
    return theme('table', array('header' => $header, 'rows' => $rows, 'sticky' => FALSE, 'attributes' => array('id' => 'ief-entity-table')));
  }
}

/**
 * Implements hook_field_widget_error().
 */
function inline_entity_form_field_widget_error($element, $error) {
  form_error($element, $error['message']);
}

/**
 * Move form elements into fieldsets for presentation purposes.
 *
 * Inline forms use #tree = TRUE to keep their values in a hierarchy for
 * easier storage. Moving the form elements into fieldsets during form building
 * would break up that hierarchy, so it's not an option for Field API fields.
 * Therefore, we wait until the pre_render stage, where any changes we make
 * affect presentation only and aren't reflected in $form_state['values'].
 */
function inline_entity_form_pre_render_add_fieldset_markup($form) {
  $sort = array();
  foreach (element_children($form) as $key) {
    $element = $form[$key];
    // In our form builder functions, we added an arbitrary #fieldset property
    // to any element that belongs in a fieldset. If this form element has that
    // property, move it into its fieldset.
    if (isset($element['#fieldset']) && isset($form[$element['#fieldset']])) {
      $form[$element['#fieldset']][$key] = $element;
      // Remove the original element this duplicates.
      unset($form[$key]);
      // Mark the fieldset for sorting.
      if (!in_array($key, $sort)) {
        $sort[] = $element['#fieldset'];
      }
    }
  }

  // Sort all fieldsets, so that element #weight stays respected.
  foreach ($sort as $key) {
    uasort($form[$key], 'element_sort');
  }

  return $form;
}
